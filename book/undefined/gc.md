# GC

### 마크 앤 스위프&#x20;

GC에서 사용되는 가장 기초 알고리즘입니다.

1. 할당 리스트를 순회 하면서 마크 비트를 지운다.
2. GC 루트부터 살아있는 객체를 찾는다. (DFS)
3. 찾은 객체에 마크 비트를 세팅한다.
4. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다.
   1. 힙에서 메모리를 회수해 프리 리스트에 되돌린다.
   2. 할당 리스트에서 객체를 삭제한다.



### 자바의 객체

자바에서는&#x20;

* 기본형
* 객체 레퍼런스

두가지의 값만 사용합니다.

자바는 C++와 달리 주소를 역참조하는 일반적인 메커니즘이 없고 오직 `오프셋 연산자` 만으로 필드에 엑세스 하거나 객체 레퍼런스의 메서드를 호출할 수 있습니다.

또한 자바는 call by value 방식으로만 메서드를 호출합니다.



### 핫스팟의 가비지 수집

자바는 C/C++ 계열의 환경과 달리 OS를 이용해 동적으로 메모리를 관리하지 않습니다.

대신 프로세스가 시작되면 JVM은 메모리를 할당(예약)하고 유저 공간에서 연속된 단일 메모리 풀을 관리합니다.&#x20;

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

에덴 영역은 대부분의 객체가 탄생하는 영역이고 단명객체는 다른 곳에는 위치할 수 없으므로 특별히 잘 관리 해야하는 영역입니다.

JVM은 에덴을 여러 버퍼로 나누어 각 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포합니다.\
이 구역을 `스레드 로컬 할당 버퍼(TLAB)` 라고 합니다.



### 병렬 수집

병렬 수집기는 세대 전체 콘텐츠를 대상으로 한번에, 가능한 효율적으로  가비지를 수집합니다.

* 영 세대

스레드가 에덴 영역에 객체를 할당 하려는데 자신이 할당받은 TLAB 공간은 부족하고 새 TLAB를 할당할 수 없을 때 영 세대 수집이 발생 합니다.

영 세대 수집이 실행되면 JVM은 전체 어플리케이션을 중단( STW ) 시킵니다.

핫스팟은 에덴과 서바이버 공간을 확인하여 가비지가 아닌 객체를 골라냅니다. 그 이후 세대 카운트를 늘리며 비어있는 서바이버 공간으로 모두 방출 합니다.

이후 어플리케이션 스레드를 재시작합니다.

* 올드 세대

올드 세대에 더 방출할 공간이 없으면 내부에서 재배치하여 공간을 회수합니다.

메모리 단편화를 줄이고 효율적으로 처리 가능합니다.



병렬 수집기는 세대 전체 콘텐츠를 대상으로 한번에, 가능한 효율적으로 가비지를 수집합니다.\
하지만 단점이 있는데 실행될때 마다 풀 STW를 유발합니다.

이는 올드 세대 수집시 STW 시간이 힙 크기에 비례한다는 점입니다.

