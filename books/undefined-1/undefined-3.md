# 고가용성

## <mark style="background-color:yellow;">백업</mark>

레디스는 모든 데이터를 메모리에서 관리하기 때문에 장애로 인해 **데이터 손실**의 가능성이 있다. \
데이터 복원 시점은 **서버가 재시작될 때**뿐이다. &#x20;

#### AOF

Append Only File : 모든 쓰기 작업을 차례대로 기록한다.&#x20;

* 레디스 프로토콜 형태로 저장
* 특정 시점으로 복구가 가능하다.

#### RDB

Redis DataBase : 일정 시점에 메모리에 저장된 데이터 전체를 저장(snapshot)&#x20;

* 바이너리 형태로 저장돼 직접 읽고 해석할 수 없는 형태
* 시점 단위로 여러 백업본을 저장할 수 있다.
* 복원이 빠르다.



## <mark style="background-color:yellow;">복제</mark>

### 고가용성을 위한 두가지&#x20;

**복제** - 마스터 노드의 데이터를 복제본 노드로 **실시간 복사**하는 기능

**자동 페일오버** - 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제본 노드로 리디렉션하는 기능



레디스는 멀티마스터 구조를 지원하지 않아서 복제본 노드는 읽기 전용으로 동작한다.

```
REPLICAOF <master-ip> <master-port>
```

복제본이 될 노드 B에서 해당 커맨드를 입력하면 복제 연결이 시작된다.&#x20;

복제본 노드는 마스터의 replication id와 동일한 replication id를 가진다.



## <mark style="background-color:yellow;">센티널</mark>

마스터 인스턴스에 장애가 발생하더라도 레디스를 계속 사용할 수 있도록 동작해 레디스의 다운타임을 최소화할 수 있다

* **모니터링** - 마스터, 복제본, 인스턴스의 상태를 실시간으로 확인한다.
* **자동 페일오버** - 마스터의 비정상 상태를 감지해 정상 상태의 복제본을 마스터로 승격시킨다.
* **인스턴스 구성 정보 안내** - 클라이언트에게 현재 구성에서의 마스터 정보를 알려준다. \
  페일오버가 발생하면 변경된 마스터 정보를 재전달하기 때문에 엔드포인트를 변경할 필요가 없다.

<div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-16 오후 3.39.12.png" alt=""><figcaption></figcaption></figure></div>

* 최소 3대 이상일때 정상적으로 동작하도록 설계 (SPOF 방지)
* 쿼럼을 통해 일정 값 이상의 동의가 이루어지면 페일오버 진행&#x20;
* replica-priority 값이 가장 작은 노드를 마스터로 선출 (기본값 100, 0은 절대 마스터로 선출 X)&#x20;



### 센티널 페일오버 과정

1. **장애상황 감지**

sdown - 주관적인 다운 상태 (하나의 센티널 노드만 다운을 체크한 상황)

odown -  객관적인 다운 상태 (쿼럼값 이상의 노드에서 장애를 체크한 상황)

2. **에포크 증가**&#x20;

페일오버를 **시작하기 전 에포크 값을 하나 증가**

동일한 에포크 값을 이용해 페일오버 과정이 진행되는 동안 모든 센티널 노드가 **같은 작업을 하는것을 보장**

3. **센티널 리더 선출**

다른 센티널 노드들에게 리더를 선출하기 위해 투표하라는 메시지를 보낸다.

**하나의 에포크에서 하나의 센티널에 투표**가능, 결과 변경 X

4. **복제본 선정 후 마스터로 승격**
   1. redis.conf 파일에 명시된 replica-priority가 낮은 복제본
   2. 마스터로부터 더 많은 데이터를 수신한 복제본
   3. b 조건까지 동일하다면 , runID 가 사전 순으로 작은 복제본



## <mark style="background-color:yellow;">클러스터</mark>&#x20;



**확장성**은 운영 중인 시스템에서 **증가하는 트래픽에 유연하게 대응**할 수 있는 능력을 뜻한다.

**스케일 업** - 하드웨어 성능을 높은 사양으로 업그레이드 (**수직 확장**), 간단하지만 한계가 있음

**스케일 아웃** - 서버를 추가하여 처리 대수를 증가 (**수평 확장**), 분산처리에 대한 로직을 개발하여야 한다.



레디스는 단일 스레드로 동작하기 때문에 서버에 CPU를 추가해도 동시에 활용할 수 없다.



### 레디스 클러스터의 기능&#x20;

* **데이터 샤딩**
  * 여러 서버 간에 데이터를 분할하려 저장하는 아키텍처&#x20;
  * 하나의 키는 항상 하나의 마스터 노드에 매핑된다.&#x20;
* **고가용성**
  * 클러스터에 속한 각 노드는 서로를 모니터링하여 장애 발생시 자동 페일오버
  * 모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결돼 있는 풀 메쉬 토폴로지 형태&#x20;



### 레디스 클러스터 동작 방법&#x20;

* **해시슬롯**을 이용한 데이터 샤딩
  * 총 16,384개의 해시슬롯을 가지며 모든 데이터는 해시슬롯에 저장된다.&#x20;
  * 마스터 노드의 개수에따라 가지고있는 슬롯의 범위가 달라지게 된다.&#x20;
  * 키를 CRC16 으로 먼저 한 번 암호화한 다음 16384 라는 값으로 나눈 나머지 값을 이용해 해시슬롯이 결정된다
*   **해시 태그**&#x20;

    * 클러스터 사용시 다중 키 커맨드는 사용이 불가하다.
    * 해시 태그(대괄호 사이에 있는 값)을 통해 동일한 슬롯에 해싱되도록 할 수 있다.

    <div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-16 오후 6.10.27.png" alt=""><figcaption></figcaption></figure></div>

```
user:{123}:profile
user:{123}:account
```

해시태그가 없으면 키가 달라서 다른 슬롯에 저장되어야 하지만 해시태그를 이용하여 같은 값으로 해싱된다.&#x20;

* **자동 재구성**
  * 모든 노드는 클러스터 버스를 통해 통신하며, 인스턴스에 문제가 생겼을 때 자동으로 클러스터를 재구성한다.
  * 복제본 노드를 마스터로 승격시키는 **자동 페일오버**
  *   잉여 복제본 노드를 다른 마스터에 연결 시키는 **복제본 마이그레이션**



      <div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-16 오후 6.17.59.png" alt=""><figcaption></figcaption></figure></div>
* **하트비트 패킷**
  * 노드들은 지속적으로 서로의 상태를 확인하기 위해 PING, PONG 패킷을 주고받는다. &#x20;
  * 노드ID, 에포크, 노드 플래그, 비트맵, TCP 포트, 클러스터 포트, 클러스터 상태, 마스터 노드 ID 를 가진다.&#x20;
  * 클러스터 생성시 모든 노드의 현재 에포크는 0, 수신받은 패킷의 에포크 값이 로컬 값보다 크다면 업데이트 &#x20;
* **리디렉션**&#x20;
  * MOVE - 해시슬롯 맵을 업데이트하여 이후 발생하는 요청은 모두 이동
  * ASK - 해시슬롯 맵을 업데이트 하지 않고 한번만 리디렉션 (마이그레이션시 사용됨)
* **장애감지**
  * PFAIL 플래그 - 하나의 노드에서 PING을 보냈지만 TIMEOUT이된 상태
  * FAIL 플래그 - 일정시간 내에 다른 노드에서 PFAIL, FAIL 알림을 받으면 FAIL로 플래깅 한다.&#x20;











