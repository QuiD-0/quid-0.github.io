# 운영 체제



### <mark style="background-color:yellow;">운영 체제</mark>

**멀티 프로그래밍** - 한 순간에 하나 이상의 프로그램이 실행되는 기능\
데이터가 로딩되는걸 기다리는 동안 다른 프로세스가 CPU를 사용

**프로세스** - 실행중인 프로그램 (램에 올라간 프로그램)

커널 - 리소스를 관리하는 소프트웨어, OS커널은 운영체제의 핵심 기능을 구현한다.&#x20;

* 시스템 콜 인터페이스 - 사용자 프로그램에서 사용&#x20;
* 장치 인터페이스 - 하드웨어와 동작하기 위해 사용&#x20;

<div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-14 오후 2.20.43.png" alt=""><figcaption></figcaption></figure></div>

**시스템에서 프로그램 실행 과정**

1. 바이너리를 디스크에서 램으로 로딩
2. 새로운 프로세스를 생성하고 초기화
3. CPU상태를 초기화하고 프로세스 실행&#x20;

**OS 실행 과정 (부팅)**&#x20;

1. &#x20;펌웨어게 저장된 코드 실행 (BIOS, UEFI등)
2. 부트 블록을 디스크에서 램으로 로드
3. CPU에서 부트 블록을 실행할 수 있을만큼의 하드웨어를 초기화
4. OS가 시작되면 디스크에서 남은 부분을 로딩



### <mark style="background-color:yellow;">인터럽트</mark>&#x20;

<div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-14 오후 2.30.07.png" alt=""><figcaption></figcaption></figure></div>

**시스템콜 (소프트웨어 인터럽트)**

* 사용자 프로그램이 커널의 기능을 사용하기 위해 호출하는 함수
* `read()`, `write()`, `fork()`

**인터럽트(하드웨어 인터럽트)**

* 하드웨어가 커널에게 데이터 처리를 위해 보내는 신호&#x20;
* 키 입력, 네트워크 패킷 수신

**트랩**

* **의도적인 트랩:** 시스템 콜 실행 (사용자 프로그램이 명령어를 실행해서 발생)
* **예외(Exception) 트랩:** 잘못된 메모리 접근(페이지 폴트), 0으로 나누기 등의 예외 발생 시 실행됨.



인터럽트 발생시 CPU는 OS의 인터럽트 핸들러 코드를 실행한다. \
처리가 끝나면 중단된 사용자 프로그램은 인터럽트가 발생한 시점의 위치에서 다시 시작

OS는 CPU사이클의 어느 시점에서든 인터럽트 핸들러 코드로 전환할 수 있다.

<div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-14 오후 2.42.35.png" alt=""><figcaption></figcaption></figure></div>

### <mark style="background-color:yellow;">프로세스</mark>

시스템에서 실행되는 프로그램의 인스턴스 / 추상화된 프로그램

한 프로세스가 CPU에서 실행될 때는 해당 프로세스에 할당된 실행 상태와 시스템 시소스에만 접근하도록 보장\
OS는 프로세스를 서로 격리시켜 다른 프로세스의 동작으로부터 보호한다.



**타임셰어링**

짧은 시간동안 여러 프로세스가 CPU에서 번갈아 실행되도록 스케줄링 &#x20;



**컨텍스트 스위칭**

1. OS는 현재 CPU에서 실행되는 PC, 스택 포인터, 범용 레지스터, 조건 코드와 같은 컨텍스트를 저장한다.
2. 다른 프로세스에서 저장된 컨텍스트를 복원하고 CPU에서 이 프로세스를 실행 시킨다.



**프로세스 실행 상태**

**대기** - 프로세스가 실행될 수 있지만 아직 스케줄링 되지 않은 상태\
**실행** **중** - CPU에 스케줄링 됐고,실제로 명령을 실행하는 상태\
**블록됨** - 실행을 재개하기 위해 특정 이벤트를 대기하는 상태\
**종료됨** - 종료됐지만, 시스템에서는 아직 완전히 제거되지 않은 상태&#x20;



**프로세스 생성 및 파기**&#x20;

모든 프로세스는 **init 프로세스**의 자식 프로세스&#x20;

`fork()`  명령을 통해 **프로세스 복제 (동일 코드 실행됨)**\
부모 프로세스에는 자식 프로세스의 PID 반환, 자식 프로세스에는 PID 0 반환

`exec()` 명령을 통해 새로운 **프로세스 생성** \
실행 중이던 프로세스가 사라지고 **새로운 프로그램이 실행**됨

`wait()` 자식 프로세스가 **끝날때까지 대기** \
자식 프로세스가 종료되면 부모는 **자식의 종료 상태를 수집**하여 좀비 프로세스를 방지

`exit()` 현재 **프로세스를 종료**\
부모 프로세스가 `wait()`으로 수집할 때까지 **좀비 프로세스** 상태가 됨



### <mark style="background-color:yellow;">가상 메모리</mark>&#x20;

OS의 프로세스 추상화는 각 프로세스에 가상 메모리 공간을 제공, \
즉 프로세스는 자신의 가상 주소 공간에서만 상호작용할 수 있다.&#x20;

<div align="left"><figure><img src="../../.gitbook/assets/스크린샷 2025-03-14 오후 3.14.43.png" alt=""><figcaption></figcaption></figure></div>

* 맨 위 부분은 OS용으로 예약되어있으며 커널 모드에서만 접근가능
* 코드와 데이터 부분은 프로그램 실행 파일에서 초기화(a.out)
* 스택 공간은 프로세스가 함수를 호출할때마다 커진다.
* 힙 공간은 동적으로 메모리 공간이 할당되면 커진다.

**메모리 주소**

**가상주소** - 프로세스의 가상 주소 공간에 있는 저장소 위치\
두개의 프로세스가 동일한 바이너리 파일을 실행하면 함수 코드와 전역변수에 대해서는 완전히 동일한 가상 주소를 가진다.&#x20;

**물리주소** - 물리메모리(RAM)에서의 저장소 위치 \
동일한 가상 주소를 가지더라도 실제로 저장되는 물리주소는 다르다.



**가상주소 -> 물리주소 변환**

**메모리 관리 장치** - 주소 변환을 구현하는 컴퓨터 하드웨어의 일부 \
어플리케이션이 메모리에 접근할때 OS와 함께 가상 주소를 물리 주소로 변환한다.&#x20;



**페이징**&#x20;

OS는 각 프로세스의 가상 주소 공간을 페이지라 불리는 고정된 크기의 덩어리로 나눈다. 기본 4KB

**가상 메모리 구현**&#x20;

메모리는 **높은 지역성**을 보이고 이를 활용하여 효율적인 RAM사용법을 설계할 수 있다.\
RAM을 디스크의 캐시처럼 사용하여 **가상 메모리의 일부만 로딩**하고 **그 외의 페이지는** \
**2차 저장 장치**에 남겨둔다.&#x20;

**페이지 폴트** - RAM에 저장되지 않은 페이지에 접근

페이징은 메모리에 접근 하려면 RAM에 두번 접근해야한다. \
이때 **변환 색인 버퍼(TLB)**&#xB97C; 사용하여 하드웨어 수준에서 매핑하는 페이지 테이블을 캐시할 수 있다.  \


### <mark style="background-color:yellow;">프로세스 간 통신</mark>&#x20;

**시그널** - OS가 프로세스에 전달하는 소프트웨어 인터럽트\
시그널을 받은 프로세스는 동작을 중단하고 시그널 핸들러 코드를 실행

**시그널과 인터럽트의 차이점**

* **시그널**: 프로세스 간 또는 커널에서 프로세스로 보내는 **소프트웨어 이벤트**.
* **인터럽트**: **하드웨어나 OS가 CPU에 보내는 신호**, 실행 중인 작업을 중단하고 인터럽트 핸들러 실행.



**파이프** - 단방향 커뮤니케이션 채널, 같은 머신에서 실행되는 두 프로세스가 사용   \
한쪽은 쓰기만 다른 한쪽은 읽기만 담당한다.&#x20;

ps -ef | grep "test"

&#x20;

**소켓** - 양방향 커뮤니케이션 채널 \
동일한 컴퓨터에서 실행되는 프로세스는 물론, 네트워크로 연결된 다른 컴퓨터의 프로세스도 통신&#x20;



**공유 메모리** -  프로세스들이 가상 주소 공간의 일부를 공유하도록 허가\
해당 부분에 값을 읽고 써서 프로세스들이 통신한다.&#x20;



